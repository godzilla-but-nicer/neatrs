use crate::community::organism::Organism;
use crate::community::genome::Genome;
use crate::community::community_params::{SpeciesParams, CrossoverMode};
use crate::neural_network::edge::Edge;

use rand::prelude::*;
use crossbeam::thread;

const NUM_THREADS: usize = 6;

#[derive(Debug)]
pub struct Species {
    id: usize,
    size: usize,
    pub population: Vec<Organism>,
    params: SpeciesParams, 
}

impl Species {
    // adds an organism to the population
    pub fn add_from_genome(&mut self, gen: Genome) {
        let new_org = Organism::new(gen);
        self.population.push(new_org);
    }

    // produce a random member to check compatibility
    pub fn get_random_specimen(&self) -> &Organism {
        let mut rng = rand::thread_rng();
        let specimen_i = rng.gen_range(0..self.size);
        &self.population[specimen_i]
    }

    // reproduction, 
    // reproduces as side effect returns the number of new innovation numbers generated
    pub fn reproduce(&mut self, target_size: usize, max_innov: usize) -> usize {        

        // determine who reproduces and who passes unchanged
        let mut modifications = 0;
        let mut reproducers = self.get_reproducers();
        let elites = self.get_elites(self.params.num_elites);
        let mut new_population: Vec<Organism>;

        // elites pass down directly with no mutation
        for elite_i in elites {
            let new_elite = Organism::new(self.population[elite_i].genome);
            new_population.push(new_elite);
        }

        // initialize rng for random mating
        let rng = rand::thread_rng();

        // each non-elite organism is generated by mating of two other organisms
        for _ in self.params.num_elites..target_size {

            // we need a random pairing
            reproducers.shuffle(&mut rng);
            let mom = self.population[reproducers[0]];
            let dad = self.population[reproducers[1]];
            let parents = [&mom, &dad];

            // align genomes and crossover into new genome
            let mut new_genome = self.crossover(mom, dad, max_innov);

            // mutate the new genomes
            if thread_rng().gen() < self.params.prob_structural {
                // genomes are mutated as a side effect. I don't love this
                modifications += new_genome.mutate(max_innov + modifications, true);
            } else {
                modifications += new_genome.mutate(max_innov, false);
            }

            // grow the next populaation
            new_population.push(Organism::new(new_genome));
        }

        // update the species and return the number of new innovation numbers
        self.population = new_population;
        self.size = target_size;
        
        modifications
    }

    // determine indices of reproducing organisms
    fn get_reproducers(&self) -> Vec<usize> {

        // sort population indices by fitness
        let fit_idx = self.sorted_pop_indices();

        // get the top fraction given in the config
        let mate_float = (self.size as f64) * self.params.mate_fraction;
        let mate_number = mate_float.round() as usize;
        
        // return the indices that get to reproduce
        fit_idx[0..mate_number].to_vec()
    }

    // get descending fitness-sorted population indices
    fn sorted_pop_indices(&self) -> Vec<usize> {
        let mut indices: Vec<usize> = (0..self.size).collect();

        // this long statement does the actual sorting
        indices.sort_unstable_by(|a, b| 
            self.population[*b].raw_fitness.partial_cmp(
            &self.population[*a].raw_fitness)
            .unwrap());

        indices
    }

    // calls the correct crossover function
    fn crossover(&self, mom: Organism, dad: Organism, max_innov: usize) -> Genome {

        let new_genome;

        if self.params.crossover_mode == CrossoverMode::Alternating {
            new_genome = Self::alternating(mom, dad, max_innov);
        } else {
            new_genome = Self::simple_random(mom, dad);
        }

        new_genome
    }

    // specific crossover functions go here
    fn alternating(mom: Organism, dad: Organism, max_innov: usize) -> Genome {
        let alignment = mom.genome.align(&dad.genome, max_innov);

        let mut new_node_ids: Vec<usize> = Vec::new();
        let mut new_edges = Vec::new();

        for gene_innov in 0..alignment.0.len() {

            // check which donor donates current edge gene 
            let new_edge: Edge;
            if gene_innov % 2 == 0 {
                let mom_idx = mom.genome.index_from_innov(gene_innov);
                let new_edge = mom.genome.edge_genes[mom_idx].clone();
            } else {
                let dad_idx = dad.genome.index_from_innov(gene_innov);
                let new_edge = dad.genome.edge_genes[dad_idx].clone();
            }
            
            // we also need to catalog all of the nodes that are required by the edges
            if new_node_ids.contains(&new_edge.source_i) {
                new_node_ids.push(new_edge.source_i)
            }

            if new_node_ids.contains(&new_edge.target_i) {
                new_node_ids.push(new_edge.target_i)
            }

            new_edges.push(new_edge);
        }

        // Now we need to handle the nodes we will again alternate
        new_node_ids.sort();
        let new_nodes = Vec::new();

        for node in new_node_ids {

            if node % 2 == 0 {

                // we need to be sure that the node is actually in the right genome
                if mom.genome.node_genes.len() > node {
                    new_nodes.push(mom.genome.node_genes[node]);
                } else {
                    new_nodes.push(dad.genome.node_genes[node])
                }

            } else {

                if mom.genome.node_genes.len() > node {
                    new_nodes.push(mom.genome.node_genes[node]);
                } else {
                    new_nodes.push(dad.genome.node_genes[node])
                }
            }
        }

        Genome::new(new_nodes, new_edges, 
                    mom.genome.sensor_idx, 
                    mom.genome.output_idx)
    }

    fn simple_random(mom: Organism, dad: Organism, max_innov: usize) {
        // start with alignment
        let alignment = mom.genome.align(&dad.genome,
                                                               max_innov);

        // select random parents for nodes
        for gene_innov in 0..alignment.0.len() {
            if gene_innov < mom.genome.edge_genes.len() && node 
        }

        // select random parents for edge genes

    }

    // calculates the raw fitness value that must be adjusted before doing any
    // evolution with it
    // should probably be broken up. e.g. spawn_fitness_thread() or spawn chunk_threads()
    fn calculate_raw_fitness(&self, ffunc: fn(&Organism) -> f64) -> Vec<f64> {

        // we're going to recieve indices and values from the child threads
        let mut i_fit_pairs = Vec::new();

        // for multithreading we need to calculate fitness in chunks
        let chunks = self.size / NUM_THREADS;
        let remainder = self.size % NUM_THREADS;
        
        for chunk_i in 0..chunks {
            
            let chunk_start = chunk_i * NUM_THREADS;
            
            // scope per chunk in which all multithreading will occur
            let s = thread::scope(|s| {

                // this vector contains the data passed from child threads
                let mut handles: Vec<thread::ScopedJoinHandle<(usize, f64)>> = Vec::new();
                for org_j in 0..NUM_THREADS {

                    // add handles for organism index and fitness from thread
                    handles.push(s.spawn(move |_| {
                        let raw_fitness = ffunc(&self.population[org_j]);
                        (chunk_start + org_j, raw_fitness)
                    }));
                }

                // move the handle data into a return vector for the scope
                let mut chunk_data = Vec::new();
                for handle in handles {
                    chunk_data.push(handle.join().unwrap());
                }
                chunk_data
            });
            
            // add data from scoped threads to main thread vector
            i_fit_pairs.append(&mut s.unwrap());
        }

        
        // now we have to calculate the ending partial chunk
        let remain_start = i_fit_pairs.len();

        // this is the same as the inner loop above
        let s = thread::scope(|s| {
            let mut handles: Vec<thread::ScopedJoinHandle<(usize, f64)>> = Vec::new();
            for org_j in 0..remainder {
                handles.push(s.spawn(move |_| {
                    let raw_fitness = ffunc(&self.population[org_j]);
                    (remain_start + org_j, raw_fitness)
                }));
            }

            // unpack the handles
            let mut remain_data = Vec::new();
            for handle in handles {
                remain_data.push(handle.join().unwrap());
            }
            remain_data
        });

        // add remaining values
        i_fit_pairs.append(&mut s.unwrap());

        // we will use the data from the scope to fill the ordered vector
        let mut raw_fitness = vec![0.0; self.size];
        for (org_j, fitness) in &i_fit_pairs {
            raw_fitness[*org_j] = *fitness;
        }

        raw_fitness
    }

    // returns the adjusted fitness values for each individual
    pub fn calculate_fitness(&self, ffunc: fn(&Organism) -> f64) -> Vec<f64> {

        let raw_fitness = self.calculate_raw_fitness(ffunc);
        let mut adj_fitness = Vec::with_capacity(raw_fitness.len());

        // normalize by population size
        for raw_fit in raw_fitness {
            adj_fitness.push(raw_fit / (self.size as f64));
        }

        adj_fitness
    }

    // constructors
    pub fn new(id: usize) -> Species {
        Species {
            id,
            size: 0,
            population: Vec::new(),
            params: SpeciesParams::new(),
        }
    }
    
    // used for testing
    pub fn _add_organism(&mut self, org: Organism) {
        self.population.push(org);
        self.size += 1;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sorted_pop_fitness() {
        // built a species with some organisms
        let spe = Species::new(0);
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));

        // assign some arbitrary fitness values
        spe.population[1].raw_fitness = 100.0;
        spe.population[2].raw_fitness = 10.0;
        spe.population[0].raw_fitness = 1.0;

        let sorted_idx = spe.sorted_pop_indices();

        assert_eq!(vec![1, 2, 0], sorted_idx);
    }

    #[test]
    fn test_get_reproducers() {
        // built a species with some organisms
        let spe = Species::new(0);
        spe.params = SpeciesParams::get_test_params();
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));
        spe._add_organism(Organism::new(Genome::new_dense(2, 2)));

        // assign some arbitrary fitness values
        spe.population[1].raw_fitness = 100.0;
        spe.population[2].raw_fitness = 10.0;
        spe.population[0].raw_fitness = 1.0;
        
        let reproducers = spe.get_reproducers();

        assert_eq!(reproducers, vec![1, 2]);
    }

    // this test is a bit weak. should compare different length genomes
    #[test]
    fn test_alternating() {

        // We'll start by making dense genomes and then replace the edges
        let mut gen_1 = Genome::new_dense(2, 2);
        let mut gen_2 = Genome::new_dense(2, 2);

        // set the weights to something we can track
        for g in 0..gen_1.edge_genes.len() {

            // pull out unchanging things from the extant edge
            let innov = gen_1.edge_genes[g].innov;
            let in_node = gen_1.edge_genes[g].source_i;
            let out_node = gen_1.edge_genes[g].target_i;

            gen_1.edge_genes[g] = Edge::new(innov, in_node, out_node, 1.0);
            gen_2.edge_genes[g] = Edge::new(innov, in_node, out_node, 2.0);
        }

        // same for the nodes and their biases
        for g in 0..gen_1.node_genes.len() {

            gen_1.node_genes[g].bias = 1.0;
            gen_2.node_genes[g].bias = 2.0;
        }
        
        // build the alternating genome
        let alternating_genome = Species::alternating(Organism::from(gen_1), 
                                                              Organism::from(gen_2), 
                                                              3);


        assert_eq!(alternating_genome.edge_genes[0].weight, 1.0);
        assert_eq!(alternating_genome.edge_genes[1].weight, 2.0);
        assert_eq!(alternating_genome.edge_genes[2].weight, 1.0);
        assert_eq!(alternating_genome.edge_genes[3].weight, 2.0);

        assert_eq!(alternating_genome.node_genes[0].bias, 1.0);
        assert_eq!(alternating_genome.node_genes[1].bias, 2.0);
        assert_eq!(alternating_genome.node_genes[2].bias, 1.0);
        assert_eq!(alternating_genome.node_genes[3].bias, 2.0)

    }

    #[test]
    fn test_calculate_raw_fitness() {

        fn n_genes(org: &Organism) -> f64 {
            org.genome.edge_genes.len() as f64
        }
        
        // genome size is easy test fitness func
        let gen_1 = Genome::new_dense(2, 1);
        let gen_2 = Genome::new_dense(3, 1);
        let gen_3 = Genome::new_dense(3, 2);
        
        let mut test_species = Species::new(0);
        test_species.add_from_genome(gen_1);
        test_species.add_from_genome(gen_2);
        test_species.add_from_genome(gen_3);
        
        let fitness_vals = test_species.calculate_raw_fitness(n_genes);

        assert!((fitness_vals[0] - 2.0).abs() < 1e5);
        assert!((fitness_vals[1] - 3.0).abs() < 1e5);
        assert!((fitness_vals[2] - 6.0).abs() < 1e5)
    }

}